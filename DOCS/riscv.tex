\documentclass[12pt]{article}

\usepackage[a4paper,inner=1.0in,outer=1.2in,top=1in,bottom=1.5in,footskip=0.4in]{geometry}

\author{Jesse E.J. op den Brouw\thanks{\texttt{J.E.J.opdenBrouw@hhs.nl}}\\[2ex]The Hague University of Applied Sciences}
\title{A Minimal RISC-V processor in VHDL}
\date{\today\\[2ex]\normalsize\url{https://github.com/jesseopdenbrouw/riscv-minimal}}

\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[charter]{mathdesign}
\usepackage[scale=0.92]{nimbusmono}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{rotating}


%% Making captions nicer...
\usepackage[font=footnotesize,format=plain,labelfont=bf,up,textfont=sl,up]{caption}
\DeclareCaptionLabelSeparator{emdash}{\ \ ---\ \ }
\usepackage[labelformat=simple,font=footnotesize,format=plain,labelfont=bf,textfont=sl]{subcaption}
\captionsetup[figure]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
\captionsetup[table]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
\captionsetup[subfigure]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
\captionsetup[subtable]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
%% Put parens around the subfig name (a) (b) etc. Needs labelformat simple
\renewcommand\thesubfigure{(\alph{subfigure})}
\renewcommand\thesubtable{(\alph{subtable})}

% Parskip et al.
\usepackage{parskip}
\makeatletter
\setlength{\parfillskip}{00\p@ \@plus 1fil}
\makeatother

\usepackage{listings}
\lstset{
    basicstyle = \ttfamily,
    breaklines = true,
    showspaces=true,
    prebreak = \raisebox{-0.5ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    postbreak = \raisebox{-0.5ex}[0ex][0ex]{\ensuremath{\hookrightarrow}},
}

\usepackage{tikz}
\usetikzlibrary{backgrounds,shapes,arrows}

\usepackage{hyperref}
\hypersetup{colorlinks}

\begin{document}
\maketitle

\vfill
\begin{abstract}
\noindent
The RISC-V Instruction Set Architecture (ISA) is an open source instruction set for a processor. This means that anybody can create a processor that uses this instruction set. There are already processors available such as E2-core from SiFive. More freeware cores are available on several platforms (e.g. on GitHub). This documents describes a basic RISC-V core in VHDL. The core can only execute the RV32I unprivileged instruction set. The processor incorporates a ROM, RAM and some simple I/O. It is targeted for implementation on an FPGA. It is tested on an Intel Cyclone V with a DE0-CV development board from Terasic. The GNU C-compiler for RISC-V is used for software development. Currently only simple C programs can be compiled and run. C++ is currently not supported.

\noindent
This processor is not intended as a replacement for commercial available processors. It is intended as a study object for Computer Science students. The standard processor executes each instruction in one clock cycle because the ROM is realized with cells, except for reads from RAM which need two clock cycles. The alternative processor executes each instruction in two clock cycles because the ROM is inferred using onboard RAM, except for ROM and RAM reads which need an extra clock cycle. The processor has a simple, non-pipelined instruction decoder. Exceptions are currently not implemented. This will be for future development.

\noindent
This is work in progress. Things will certainly change in the future.
\end{abstract}
\vfill

\clearpage
\tableofcontents

\clearpage
\section{Introduction}
This document describes the buildup of a simple, single/dual clock cycle, one core, RISC-V processor, completely written in VHDL. The processor is able to run a simple compiled C-program. C++ is currently not supported. The processor can handle the RV32I Base Integer Instruction Set as set forward in ``The RISC-V Instruction Set Manual Volume I: Unprivileged ISA''. The RV32M Instruction Set is currently not supported, so multiplications and divisions have to be handled in software. The toolchain will take care of that when supplied with the correct parameters. The aim is to synthesize for a minimum clock frequency of 50\,MHz.

This RISC-V processor consists of the following building blocks:

\begin{itemize}
\item The registers contain intermediate data for calculations.
\item The ROM contains the program instructions and constant (read-only) data.
\item The RAM contains read-write data (mutable data).
\item The I/O is an interface with the outside world.
\item The ALU is responsible for almost all computations in the processor.
\item The PC is used to point to the currently executing instruction.
\item The Address Decoder and Data Router is an interface between the memory (ROM, RAM, I/O) and the ALU and registers.
\item The Instruction Decoder decodes the currently executing instruction and provides control signals to other building blocks.
\end{itemize}

A block diagram is shown in Figure~\ref{fig:blockdiagram}.

\begin{sidewaysfigure}[!p]
\centering
\begin{tikzpicture}[thick,font=\sffamily\footnotesize,>=latex,scale=.75,framed,background rectangle/.style={fill=none}]
% Demux and regs
\draw (0,0) rectangle (1,-4) node[midway,rotate=90] {rd};
\draw (1,0) rectangle (3,-4) node[midway,align=center] {REGS\\(32x32)};
\draw[->] (0.3,-5) node[below] {rd} -- (0.3,-4);
\draw[->] (0.7,-5.5) node[below] {rden} -- (0.7,-4);
\draw (3,0) rectangle (4,-2) node[midway,rotate=90] {rs2};
\draw[->] (3.0,0.5) node[left] {rs2} -- ++(0.5,0) -- ++(0,-0.5);
\draw (3,-2) rectangle (4,-4) node[midway,rotate=90] {rs1};
\draw[->] (3,-4.5) node[left] {rs1} -- ++(0.5,0) -- ++(0,0.5);
\draw (4,-3) -- (7,-3) node[midway,above] {32x32};
\draw[->] (7,-3) -- (16,-3) node[above left] {address}; 
\draw (4,-1) -- (8,-1) node[midway,above] {32x32};
\draw[->] (8,-1) -- (16,-1) node[above left] {data}; 
\draw[fill=black] (8,-1) circle (2pt);
\draw[fill=black] (7,-3) circle (2pt);

% ALU
\draw (6,-5) -- ++(7,0) node[midway,yshift=-0.8cm,font=\normalsize\sffamily] {ALU} -- ++(-1,-2) -- ++(-5,0) -- cycle;
\draw[->] (7,-3) -- (7,-5);
\draw[->] (8,-1) -- (8,-5);
\draw[->] (5.5,-6) node[left] {alu\_op} -- (6.5,-6);
\draw[->] (9.5,-7.0) -- (9.5,-8.5) -- ++(-10.5,0) -- ++(0,6.5) -- ++(1,0);
\draw[->] (11,-4.0) node[above] {pc} -- ++(0,-1);
\draw[->] (10,-4.0) node[above] {offset} -- ++(0,-1);
\draw[->] (9,-2.0) node[above,xshift=3mm] {immediate} -- ++(0,-3);

% Address decode and data route
\draw (16,-0) rectangle ++(2,-17) node[midway,align=center] {Address\\Decode\\\&\\Data\\Router};
\draw[->] (16,-4) node[above left] {data} -- ++(-4,0) -- ++(0,-1);
\draw[->] (15,-6) node[left] {size} -- ++(1,0);
\draw[->] (15,-7) node[left] {offset} -- ++(1,0);
\draw[->] (15,-8) node[left] {memaccess} -- ++(1,0);
\draw[<-] (15,-9) node[left] {waitfordata} -- ++(1,0);
\draw[->] (18,-15.5) -- ++(1,0) node[right] {wrio};
\draw[->] (18,-16.0) -- ++(1,0) node[right] {wrram};

% Instruction decoder
\draw (9,-10.5) rectangle ++(3,-6.5) node[midway,align=center] {Instruction\\Decoder};
\draw[->] (12,-11.0) -- ++(1,0) node[right] {alu\_op};
\draw[->] (12,-11.5) -- ++(1,0) node[right] {rd};
\draw[->] (12,-12.0) -- ++(1,0) node[right] {rden};
\draw[->] (12,-12.5) -- ++(1,0) node[right] {rs1};
\draw[->] (12,-13.0) -- ++(1,0) node[right] {rs2};
\draw[->] (12,-13.5) -- ++(1,0) node[right] {shift};
\draw[->] (12,-14.0) -- ++(1,0) node[right] {immediate};
\draw[->] (12,-14.5) -- ++(1,0) node[right] {size};
\draw[->] (12,-15.0) -- ++(1,0) node[right] {offset};
\draw[->] (12,-15.5) -- ++(1,0) node[right] {pc\_op};
\draw[->] (12,-16.0) -- ++(1,0) node[right] {memacces};
%\draw[->,red] (12,-16.5) -- ++(1,0) node[right] {error};
\draw[->] (8,-12) node[left] {instruction} -- ++(1,0);
\draw[->] (8,-13) node[left] {waitfordata} -- ++(1,0);
%\draw[->,red] (8,-15) node[left] {intreq} -- ++(1,0);

% ROM
\draw (22,-1) rectangle ++(2,-3) node[midway,align=center,yshift=0.4cm] {ROM\\(Dual Port)};
\draw[<-] (24,-2.5) -- ++(1,0) node[right] {PC};
\draw[->] (24,-3.0) -- ++(1,0) node[right] {instruction};
\draw[->] (18,-2) -- ++(4,0) node[midway,above] {address+offset};

% Address lines to RAM and I/O
\draw[->] (21,-2) -- ++(0,-5) -- ++(1,0);
\draw[fill=black] (21,-2) circle (2pt);
\draw[->] (21,-7) -- ++(0,-5.5) -- ++(1,0);
\draw[fill=black] (21,-7) circle (2pt);
% Data lines from ROM, RAM, I/O
\draw[->] (22,-3) -- ++(-4,0);
\draw[->] (22,-7.5) -- ++(-4,0);
\draw[->] (22,-13.5) -- ++(-4,0);
% Data lines to RAM and I/O
\draw[->] (18,-8) -- ++(1.5,0) -- ++(2.5,0);
\draw[->] (19.5,-8) -- ++(0,-5.0) -- ++(2.5,0);
\draw[fill=black] (19.5,-8) circle (2pt);

% RAM
\draw (22,-6) rectangle ++(2,-3) node[midway,align=center] {RAM\\(onboard)};
\draw[->] (23,-10) node[below] {wrram} -- ++(0,1);

% I/O
\draw (22,-11.5) rectangle ++(2,-3) node[midway] {I/O};
\draw[->] (23,-15.5) node[below] {wrio} -- ++(0,1);
\draw[<->] (24,-12.5) -- ++(1,0) node[right] {I/O lines};
%\draw[->] (24,-13.5) -- ++(1,0) node[right] {interrupts};

% PC
\draw (3,-12) rectangle ++(2,-4) node[midway] {PC};
\draw (2,-12) rectangle ++(1,-4) node[midway, rotate=90] {mux};
\draw[->] (5,-14) -- ++(1,0) -- ++(0,-3) -- ++ (-6,0) -- ++(0,4.333) -- ++(1,0);
\draw[->] (6,-14) -- ++(1,0) node[right] {pc};
\draw[fill=black] (6,-14) circle (2pt);
\draw[->] (0,-13.5) -- ++(1,0);
\draw[fill=black] (0,-13.5) circle (2pt);

\draw (1,-12) rectangle ++(1,-1) node[midway] {+};
\draw (1,-13) rectangle ++(1,-1) node[midway] {+4};
\draw (1,-14) rectangle ++(1,-1) node[midway] {+};
\draw (1,-15) rectangle ++(1,-1) node[midway] {+};
\draw[->] (2.5,-11) node[above] {pc\_op}-- ++(0,-1);

\draw[->] (1.5,-8.5) -- ++ (0,-3.5) node[xshift=-3mm,midway,rotate=90] {result(0)};
\draw[fill=black] (1.5,-8.5) circle (2pt);

\draw[->] (0,-14.6667) -- ++(1,0);
\draw[fill=black] (0,-14.6667) circle (2pt);

\draw[->] (-0.5,-11.333) node[above] {offset} -- ++(0,-1) -- ++(1.5,0);
\draw[->] (-0.5,-12.333) -- ++(0,-2) -- ++(1.5,0);
\draw[fill=black] (-0.5,-12.333) circle (2pt);
\draw[->] (-0.5,-14.333) -- ++(0,-1) -- ++(1.5,0);
\draw[fill=black] (-0.5,-14.333) circle (2pt);

\draw[->] (-0.5,-17.6667) node[below] {rs1\_data} -- ++(0,2) -- ++(1.5,0);
\end{tikzpicture}
\caption{The complete RISC-V MCU.}
\label{fig:blockdiagram}
\end{sidewaysfigure}



\section{Registers}
The processor consists of thirty-two 32-bit registers denoted by \texttt{x0} to \texttt{x31}. Internally, the registers use Big Endian format. Register \texttt{x0} (alias \texttt{zero}) is hardwired to all zeros. Writing this register has no effect. Reading this register returns all zero bits. Normally, the \texttt{x}-names are not used. Table~\ref{tab:registers} shows the names of the registers as they should be used.

\begin{table}[!ht]
\centering
\caption{RISC-V registers and their purpose.}
\label{tab:registers}
\begin{tabular}{lllc}
Register & Name & Purpose & Saver \\
\midrule
\texttt{x0}      & \texttt{zero}   & Hard-wired zero                   & $-$ \\
\texttt{x1}      & \texttt{ra}     & Return address                    & Caller \\
\texttt{x2}      & \texttt{sp}     & Stack pointer                     & Callee \\
\texttt{x3}      & \texttt{gp}     & Global pointer                    & $-$ \\
\texttt{x4}      & \texttt{tp}     & Thread pointer                    & $-$ \\
\texttt{x5}      & \texttt{t0}     & Temporary/alternate link register & Caller \\
\texttt{x6-x7}   & \texttt{t1-t2}  & Temporaries                       & Caller \\
\texttt{x8}      & \texttt{s0/fp}  & Saved register/frame pointer      & Callee \\
\texttt{x9}      & \texttt{s1}     & Saved register                    & Callee \\
\texttt{x10-x11} & \texttt{a0-a1}  & Function arguments/return values  & Caller \\
\texttt{x12-x17} & \texttt{a2-a7}  & Function arguments                & Caller \\
\texttt{x18-x27} & \texttt{s2-s11} & Saved registers                   & Callee \\
\texttt{x28-x31} & \texttt{t3-t6}  & Temporaries                       & Caller
\end{tabular}
\end{table}

\section{ROM}
\label{sec:rom}
The ROM consists of bytes and is only word addressable for instructions. The ROM is byte, half word and word addressable when reading constant data. Half word and word entries are in Litte Endian format. When reading data from the ROM, halfword accesses must be on 2-byte boundaries and word accesses must be on 4-byte boundaries. This simplifies the decoding circuitry. The ROM returns undefined data if an access is not aligned. The standard processor instantiates the ROM in cells, which limits the size of the program. The alternative processor instantiates the ROM in onboard RAM, so bigger programs are possible. Rearranging half word and word data accesses in Big Endian format is handled by the ROM decoding unit.

Note: the alternative processor uses onboard RAM to simulate ROM. Because of this, each read from RAM (instruction and data) requires two clock cycles. See Section~\ref{sec:ram}.

\section{RAM}
\label{sec:ram}
The RAM consists of bytes and is byte, halfword and word addressable. Half word and word entries are in Little Endian format. The RAM itself is made up of word (i.e. 32-bit) entries and is instantiated with onboard RAM blocks. Due to this fact, halfword accesses are only permitted on 2-byte boundaries and word accesses are only permitted on 4-byte boundaries. The RAM returns undefined data if an access is not aligned. Writes will not take place if an access is unaligned. This simplifies the decoding circuitry. For the Cyclone V a maximum of 65536 words of RAM can be instantiated. Rearranging half word and word data accesses in Big Endian format is handled by the RAM decoding unit.

Note: the Cyclone V has 3,153,920 bits of RAM available. Because of the 32-bit entries a maximum of 2,097,152 (65536 x 32) bits can be instantiated. This is equivalent to 262,144 bytes.

Writing the RAM (byte, half word of word) requires 1 clock cycle. Reading the RAM (byte, half word, word) requires 2 clock cycles because the RAM output is buffered by a register. This is automatically handled by the processor.

\section{I/O}
\label{sec/io}
Currently, the I/O consists of one 32-bit data input and one 32-bit data output. More I/O (timers/counter etc.) will be added in the future, but most I/O requires the use of interrupts (timer overflow etc.). Note that the I/O can only be accessed as words and the addresses must be on 4-byte boundaries. If not on a 4-byte boundaries, reads return undefined data whereas writes will not write data.

\section{ALU}
\label{sec:alu}
The Arithmetic an Logic Unit (ALU) handles all computations on data. It can add, subtract, do logic operations such as AND, OR en XOR, can shift data left or right, and sign extend byte and halfword data. Some operations require two registers, some only use one register. Furthermore the ALU is also used to determine if a conditional branch should be taken. Note that the RISC-V programmer's model does not incorporate status flags as some other architectures do. This requires some extra instructions when adding or subtracting double word (64-bit) data. The ALU is also used to compute the return address from unconditional function calls (JAL and JALR instructions). The data is in Big Endian format.

Note that the computation of jump target addresses is handled by the Program Counter (PC)

\section{PC}
\label{sec:pc}
The Program Counter contains the address of the currently executed instruction. The address is always on a 4-byte boundary although function calls and conditional jump (JAL, JALR en B$xx$ instructions) can be on non 4-byte boundaries (the toolchain will always create 4-bytes boundaries). The PC (or rather the VHDL description of the PC) handles the address calculations of jumps and branches taken.

\section{Instruction Decoder}
\label{sec:instructiondecoder}
The instruction decoder decodes the instruction supplied by the ROM as pointed by the PC. An instruction is 4-bytes wide and in Little Endian order. The instruction decoder provides all control signals for the ALU, the PC, the Address Decoder and the register file.

In the standard processor, a simple two-state Finite State Machine (FSM) is used. Almost all instructions are executed in one clock cycle. Only reads from RAM require two clock cycles. The FSM takes care of that.

In the alternative processor, a simple three-state FSM is used. All instructions require two clock cycles to be fetched and an extra clock cycle is needed when reading RAM or ROM. The FSM takes care of that.

The instruction decoder is non-pipelined. That simplifies the design but slows down the computational speed.

\section{Address Decoder and Data Router}
\label{sec:addressdecoderanddatarouter}
The Address Decoder and Data Router routes reads and writes to the ROM (only reads), RAM and the I/O. The processor uses a 32-bit linear address space for ROM, RAM and I/O. In the default setting, ROM starts at address 0x00000000 and the length is implementation-defined, it depends on the program. Unused ROM addresses return don't cares (in simulation) and in hardware the data returned is implementation-defined. Currently a maximum of 16384 bytes of ROM is supported. The RAM starts at address 0x20000000 and the length can be up to 262144 bytes, in powers of 2. The I/O starts at address 0xF0000000 and the length is implementation-defined.

When data is read, the data is collected from the accessed memory and put on an internal bus to the ALU. The ALU can perform sign extension (byte and halfword accesses) if needed. Please note that reading data from the RAM and ROM requires an extra clock cycle. Reading data from I/O requires one clock cycle.

\section{Stack pointer}
The stack pointer is fully implemented although the ISA does not provided pushes and pops. The stack pointer is used to allocate local variables and is updated with each allocation and deallocation. As usual, the stack grows downwards (to lower addresses) on allocations and upwards (to higher addresses) on deallocations. Therefore the stack pointer is set to the highest RAM address on startup (which is 0x20004000 by default). The ISA postulates that the stack is aligned on 16-byte boundaries.


\section{Implemented instructions}
All RV32I Unprivileged instructions are implemented with the exception of FENCE, ECALL and EBREAK instructions. These instructions act as a no-operation (NOP). This is because exceptions are not implemented.

\section{The FPGA}
For this project, we use the Cyclone V FPGA from Intel (formerly Altera). See \url{https://www.intel.com/content/www/us/en/products/details/fpga/cyclone/v.html}.
The used Cyclone V is the 5CEFA4F23C7 which has about 18000 cells available. It has 3080 KB of onboard RAM bits available which are partially used for RAM and ROM (in the alternative processor). Depending on the program and used resources, the compiled RISC-V processor uses about 2000-2500 cells (about 12\,\% - 15\,\%). This FPGA is mounted on a Terasic DE0-CV board, see \url{http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&No=921}. For downloading the program file, the onboard USBBlaster is used.

\section{Simulation}
The designs can be simulated fully, using QuestaSim Intel Starter or ModelSim Intel Starter. You need a (free) license for QuestaSim. During simulation, all essential signals can be viewed, as is the RAM. The RAM is viewed as 32-bit entries, so we need to do some manual calculations to correctly find byte, halfword and word accesses. Simulation can be started from Quartus.

\section{Setting up the GNU C compiler}
The processor can run simple compiled C-programs that are compiled using the GNU C-compiler for RISC-V. Besides that, a separate linker script is needed to setup the compiled code. Building the C compiler (for Linux) is straightforward:

\begin{enumerate}
\item You need a current GNU C-compiler installed or your Linux box.
\item You need the texinfo package. On Ubuntu et al.\@ issue
\begin{lstlisting}[language=]
apt install texinfo
\end{lstlisting}
\item In your home directory, enter the command
\begin{lstlisting}[language=]
git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
\end{lstlisting}
\item Wait for the cloning to end (takes a long time, about 30 minutes on a Zbook G5 2020 with a 10 MB/s internet connection)
\item Change to the directory with
\begin{lstlisting}[language=]
cd riscv-gnu-toolchain
\end{lstlisting}
\item Make the \texttt{build} directory with:
\begin{lstlisting}[language=]
mkdir build; cd build
\end{lstlisting}
\item Check the current configuration with
\begin{lstlisting}[language=]
../configure --help | grep abi
\end{lstlisting}
      It should say:
\begin{lstlisting}[language=]
--with-abi=lp64d    Sets the base RISC-V ABI, defaults to lp64d
\end{lstlisting}
The toolchain is currently configured for 64-bit RISC-V. That is not what we want.
\item Enter:
\begin{lstlisting}[language=]
../configure --prefix=/opt/riscv32 --with-arch=rv32i --with-abi=ilp32
\end{lstlisting}
This will set the architecture to RV32I and the ABI to ipl32. This means that integers, long integers and pointers use 32-bit entries. The destination directory is \lstinline|/opt/riscv32|
\item Now enter the make command as root: \lstinline|make|\\
MAKE SURE TO ENTER THIS COMMAND AS root, because the toolchain is put in \lstinline|/opt/riscv32|. This takes a long time (about 45 minutes on a Zbook G5). At some points the compilation seems to hang, but it is just compiling complicated C-files. By the way, you will see a lot of warnings.
\item Now that the toolchain is setup, we have to put the path into the \lstinline|$PATH| environment variable so enter
\begin{lstlisting}[language=]
export PATH=/opt/riscv32/bin:$PATH
\end{lstlisting}
\item Check if the compiler is available:
\begin{lstlisting}[language=]
riscv32-unknown-elf-gcc -v
\end{lstlisting}
It should say something like:
\begin{lstlisting}[language=]
Using built-in specs.
COLLECT_GCC=riscv32-unknown-elf-gcc
COLLECT_LTO_WRAPPER=/opt/riscv32/libexec/gcc/riscv32-unknown-elf/11.1.0/lto-wrapper
Target: riscv32-unknown-elf
Configured with: /mnt/d/PROJECTS/RISCVDEV/riscv-gnu-toolchain/build/../riscv-gcc/configure --target=riscv32-unknown-elf --prefix=/opt/riscv32 --disable-shared --disable-threads --enable-languages=c,c++ --with-system-zlib --enable-tls --with-newlib --with-sysroot=/opt/riscv32/riscv32-unknown-elf --with-native-system-header-dir=/include --disable-libmudflap --disable-libssp --disable-libquadmath --disable-libgomp --disable-nls --disable-tm-clone-registry --src=../../riscv-gcc --disable-multilib --with-abi=ilp32 --with-arch=rv32i --with-tune=rocket 'CFLAGS_FOR_TARGET=-Os   -mcmodel=medlow' 'CXXFLAGS_FOR_TARGET=-Os   -mcmodel=medlow'
Thread model: single
Supported LTO compression algorithms: zlib
gcc version 11.1.0 (GCC) 
\end{lstlisting}
\end{enumerate}

\section{Cloning the RISC-V project}
\label{sec:cloning}
Now we have to clone the RISC-V project. It incorporates the full Quartus Prime Lite project with the processor written in VHDL. It also incorporates some simple C program examples and a taylor-made program to convert a RISC-V executable to a VHDL table suitable for the ROM. Create a working directory (and change to that directory) and issue the command:

\begin{lstlisting}[language=]
git clone https:/github.com/jesseopdenbrouw/riscv-minimal
\end{lstlisting}

In the created directory, you will see the following directories:

\texttt{CODE} -- Sample software programs\\
\texttt{DOCS} -- Documentation\\
\texttt{HARDWARE} -- the VHDL description \\
\texttt{OLD} -- yes, really old files for backup

Change directory to \texttt{CODE}. Now enter the command \texttt{make}. It will compile all programs and the taylor-made conversion program. To clean up the programs, issue the command \texttt{make clean}.

Next, start your Quartus Prime Lite software and open the project in the \texttt{HARDWARE} directory. Now start a build by clicking on the play-symbol. It should compile a standard setting (this takes a long time). When finished, you can download the FPGA contents to the DE0-CV board.

To test one of the programs, change directory to one of the directories and copy the file with \texttt{.vhd} extension to the directory containing the VHDL description under the name \texttt{processor\_common\_rom.vhd}.
Now start Quartus and start the compilation. After a successful compilation, you can program the Cyclone V on a DE0-CV board.

\section{Register subset}
It is possible to compile the toolchain to only use register \texttt{x0} to \texttt{x15}. This is called the RISC-V E extension. As a positive side effect, the register file can be cut down from 32 registers to 16 registers. This will lower the cell count and possible speed up the device. A negative side effect is that the pressure on register allocation is higher, possibly increasing instruction count when saving registers on the stack.

To configure the GNU C compiler for the E extension issue the command:

\begin{lstlisting}[language=]
../configure --prefix=/opt/riscv32 --with-arch=rv32e --with-abi=ilp32e
\end{lstlisting}

and build the compiler.

Now compile a C program with:

\begin{lstlisting}[language=]
riscv32-unknown-elf-gcc -O0 -g -o string string.c -Wall -T ../ldfiles/riscv.ld -march=rv32e -mabi=ilp32e -nostartfiles --specs=nano.specs ../crt/startup.c
\end{lstlisting}

Make sure to use \texttt{-march=rv32e} and \texttt{-mabi=ilp32e}.


\section{Compiling a C program by hand}
Note: only very, very simple C programs can be compiled for the processor at this time. We tested some simple looping (with \texttt{for}) and reading/writing the I/O. We did not test the use of the C library at this time.

Compiling a program requires the following steps:

\begin{itemize}
\item In the program directory \lstinline|CODE|, create a new directory and change to that directory.
\item Create a C program file, we assume \lstinline|flash.c|.
\item Now issue the command:
\begin{lstlisting}[language=]
riscv32-unknown-elf-gcc -O2 -g -o flash flash.c -Wall -T ../ldfiles/riscv.ld -march=rv32i -nostartfiles --specs=nano.specs ../crt/minimal.S
\end{lstlisting}
We supply our own linker file (\lstinline|-T ../ldfiles/riscv.ld|) and we supply our own startup file (\lstinline|../crt/minimal.S|). Make sure to use \lstinline|-nostartupfiles| otherwise the default startup file will be linked and errors will report. There a three startup files:
\begin{itemize}
\item \texttt{empty.S} -- Empty startup file only providing the entry symbol. Can be used with assembler programs.
\item \texttt{minimal.S} -- Loads the global pointer and stack pointer and calls \texttt{main}. On return of \texttt{main}, it waits in an endless loop. Can be used with minimalistic C programs.
\item \texttt{startup.c} -- Full support for C programs.
\end{itemize}
\item Next issue the command:
\begin{lstlisting}[language=]
riscv32-unknown-elf-objcopy -O srec flash flash.srec
\end{lstlisting}
This will create an S-record file in Motorola hex-format.
\item Next issue the command:
\begin{lstlisting}[language=]
../bin/srec2vhdl -wf flash.srec flash.vhd
\end{lstlisting}
This will create a VHDL file with the ROM encoded. Note: the taylor-made \texttt{srec2vhdl} has to be compiled before. See Section~\ref{sec:cloning}.
\item Next issue the command:
\begin{lstlisting}[language=]
cp flash.vhd ../../HARDWARE/riscv/processor_common_rom.vhd
\end{lstlisting}
This will copy the VHDL file to the RISC-V processor ROM file.
\item Now start the compilation of the VHDL code in Quartus Prime Lite and program the compiled file. This file has the extension \lstinline|.sof|. See Figures~\ref{quartus1} to~\ref{programmer}.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.85\textwidth]{quartus1}
\caption{Image of the Quartus project (1).}
\label{quartus1}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.85\textwidth]{quartus2}
\caption{Image of the Quartus project (2).}
\label{quartus2}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.85\textwidth]{programmer}
\caption{Image of the programmer.}
\label{programmer}
\end{figure}

\end{itemize}

\section{Current problem}
The linker script \texttt{riscv.ld} is not working properly. Currently it is not possible to use static/global initialized data, or uninitialized static/global data that should be set to all zero. The data \emph{is} stored in the executable (and hence in the VHDL file), but we cannot access it with linker global symbols. A workaround this problem is to explicitly set the data at startup (i.e. in \texttt{main}).

\section{Future plans}
Some future plans:

\begin{itemize}
\item Implement exceptions and interrupts in general. This will bring the possibility to add more I/O, such as timers.
%\item Implement ROM in onboard RAM. This will lower the cell count, increase the overall speed, but each ROM read requires two clock cycles.
\item Implement the M standard: multiplier and divider. Multiplication can be achieved with the onboard multipliers but division has to be handled with a multi-cycle FSM.
\item Implement more General Purpose I/O (pins), with data direction registers. On the Cyclone V this is an issue, since the tri-state buffers must be in the top level of the design. This makes it hard to implement this processor as part of greater design.
\end{itemize}

\section{Author's note}
I managed to create this basic RISC-V processor within one week, including compiling the GNU C compiler and the created C program examples. Of course, this is not the fastest core available, but it gives a good example on designing a RISC-V processor yourself. Next in line is to make the standard C library work. In the mean time, files will change, so be sure to grab the latest GitHub repository clone.
\end{document}